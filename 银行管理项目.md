## 银行管理项目

##### 利用window的Makefile，需要自行安装某些包，才能使用make指令，来简便的快速创建一个项目

```bash
GNU Make 
```

利用docker的容器镜像性，来对使用sqlc，来自动生成代码用的

```bash
docker run --rm -v "$具体项目路径:/src" -w /src sqlc/sqlc generate
```



##### 数据库的事务性，能够自动进行一次事务的提交，回滚

数据库的表格，E-R图可以使用工具

```http
https://dbdiagram.io/d
```

还可以使用迁移，来对数据库的数据表的结构，迁移到对应的版本的结构

migrate 使用指令

//用于具体的数据库表的迁移结构
```go
migrate -path db/migration -database "postgresql://postgres:cst4Ever@localhost:5432/mypostgres?sslmode=disable" -verbose down

//用于创建新的数据库迁移脚本
```bash
migrate create -ext sql -dir db/migration -seq add_sessions
```





##### 使用postman来对自己的接口进行测试，直接调用的方式





##### 使用gin框架，来快速搭建一个路由处理。这个接收数据结构体是利用gin的上下文，再解析出来的

```go
	router := gin.Default()

	router.POST("/accounts", server.CreateAccount)
	router.GET("/dsad"，任何中间件加函数)
```

从上下文中解析这个传进来的结构体

```go
func (server *Server) CreateUser(ctx *gin.Context) {
	var req createUserRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}
    ...
    
}
```





使用后Golang自定的mock，来模拟对http跟数据库的操作

使用包：

```bash
go install github.com/golang/mock/mockgen@v1.6.0
```

- 模拟数据库：需要使用一个新的接口替换掉真实链接数据库的接口
- 此处需要了解真实的接口是怎么做的
- 需要在sqlc的配置文件中，定义好一个全部接口的类型

```yaml
    emit_interface : true
```

```go
type Store interface {
	Querier
	//实现接口的定义,只要一个接口，实现了一个结构体的方式，就可以弄一个返回为同一个类型
	TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) 
}


type SQLStore struct {
	*Queries
	db *sql.DB
}
```

执行指令

```bash
mockgen -package mockdb  -destination db/mock/store.go  Project/db/sqlc Store
```

来在对应为目录生成mock代码函数

##### 在使用mock代码的时候，需要每种不同类型的请求，需要包含的参数不一样
```go
	testCases := []struct {
		name          string
		body          gin.H
		buildStubs    func(store *mockdb.MockStore)
		checkResponse func(recoder *httptest.ResponseRecorder)
		setupAuth func(t *testing.T, request *http.Request, tokenMaker token.Maker)
	}
```
- name 就是表示这个用例是测试什么情况的
- body 就是在测试这个请求的时候，给gomock发送的数据结构体
- buildStubs 用于定义这个请求预期的效果，用于参数检测的(并不完全检测参数，而是检验在mock生成代码的结构体的数据)
- checkResponse 是用于检测最终返回的值，状态码的检测
- setupAuth 用于检验令牌合理性
...

去验证每一个函数的，满足百分百的代码覆盖度

##### 在模拟发送http请求的时候，如果是需要Get的方式，需要在请求的URL上添加上需要的参数名
```go
			// Add query parameters to request URL
			q := request.URL.Query()
			q.Add("page_id", fmt.Sprintf("%d", tc.query.pageID))
			q.Add("page_size", fmt.Sprintf("%d", tc.query.pageSize))
			request.URL.RawQuery = q.Encode()

```
添加上对应的查询parameters ，最终使用 server.router.ServeHTTP(recorder, request)发送最终的请求


##### 还可以使用gin框架自带的验证传输的JSON码的格式是否符合预期

```go
var validCurrency validator.Func = func(fieldLevel validator.FieldLevel) bool {
   if curency , ok := fieldLevel.Field().Interface().(string); ok{
        return utils.IsSupportedCurrency(curency)
   }
   return false
}
```



利用这个validator助手，注册一个是否成功的函数。随后需要在gin框架初始化的时候进行注册

```go
	if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
		v.RegisterValidation("currency", validCurrency)
	}
```

```go
package api

import (
	"Project/utils"

	"github.com/go-playground/validator/v10"
)

var validCurrency validator.Func = func(fieldLevel validator.FieldLevel) bool {
   if curency , ok := fieldLevel.Field().Interface().(string); ok{
        return utils.IsSupportedCurrency(curency)
   }
   return false
}
//之后可以进行直接对JSON使用这个`json:"currency" binding:"required,currency"`
```

需要注册一个函数，返回是否通过的一个闸口


##### 设置并验证Token的方式
- 有两种方法：(重点都是围绕着这个maker来获取)
	- **JWT**
	需要创建负载，通过负载，并且添加加密方式，来创建一个
	```go
	func (maker *JWTMaker) CreateToken(username string, duration time.Duration) (string, error) {
	//创建一个新的Token负载
	payload, err := NewPayload(username, duration)
	if err != nil {
		fmt.Println(err)
		return "", err
	}
	//创建一个token令牌
	jwtTocker := jwt.NewWithClaims(jwt.SigningMethodHS256, payload)
	return jwtTocker.SignedString([]byte(maker.secretKey))
	}
	```
	随后对Token进行验证
	```go
	func (maker *JWTMaker) VerifyToken(token string) (*Payload, error) {
	//定义的一个匿名函数：作为提供验证JWT令牌需要的秘钥
	keyFunc := func(token *jwt.Token) (interface{}, error) {
		_, ok := token.Method.(*jwt.SigningMethodHMAC)
		if !ok {
			return nil, ErrInvalidToken
		}
		return []byte(maker.secretKey), nil
	}
	jwtToken, err := jwt.ParseWithClaims(token, &Payload{}, keyFunc)
	if err != nil {
		verr, ok := err.(*jwt.ValidationError)
		if ok && errors.Is(verr.Inner, ErrExpiredToken) {
			return nil, ErrExpiredToken
		}
		return nil, ErrInvalidToken
	}
	payload, ok := jwtToken.Claims.(*Payload)
	if !ok {
		return nil, ErrInvalidToken
	}
	return payload, nil
	}
	```
	- **Paseto**
	这个就简单很多，只需要调用某一个函数，给他添加上即可
	```go
	//创建
	pateoMaker.paseto.Encrypt(pateoMaker.symmertricKey, payload, nil)
	//验证
	pateoMaker.paseto.Decrypt(token, pateoMaker.symmertricKey, payload, nil)
	```
	```go
	func (pateoMaker *PateoMaker) CreateToken(username string, duration time.Duration) (string, error) {
	payload, err := NewPayload(username, duration)
	if err != nil {
		return "", err
	}
	return pateoMaker.paseto.Encrypt(pateoMaker.symmertricKey, payload, nil)
	}
	```



##### 哈希对用户的密码进行加密存储在数据库中
- 通过有一个固定次序，来对每一次密码进行加密,即使相同的密码，他们的哈希密码也还是不同的



##### 检验每一次申请连接的令牌是否超出预期
- 有敏感数据的话，需要重新定义一个response的数据结构
```go
type userResponse struct {
	Username          string    `json:"username"`
	FullName          string    `json:"full_name"`
	Email             string    `json:"email"`
	PasswordChangedAt time.Time `json:"password_changed_at"`
	CreatedAt         time.Time `json:"created_at"`
}

func newUserResponse(user db.User) userResponse {
	return userResponse{
		Username:          user.Username,
		FullName:          user.FullName,
		Email:             user.Email,
		PasswordChangedAt: user.PasswordChangedAt,
		CreatedAt:         user.CreatedAt,
	}
}

	rep := newUserResponse(user)
	ctx.JSON(http.StatusOK, rep)
```


##### 令牌的作用：某些查询或者操作的指令，必须拥有访问的token，才能有权限修改或者查询，否则无法进行
- 也就是说：很多API的请求结构体要发生变化，不需要再提供关于自己的用户名，而是通过保存在请求里面的Token进行获取
- 这样就避免用户端那边在发送请求的时候进行作弊
- 也就是说，需要从上下文的存储的自定义的负载中，获取想要的信息
	```go
	type Payload struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	IssuedAt  time.Time `json:"issued_at"`
	ExpiredAt time.Time `json:"expired_at"`
	}
	```




###### 使用gin提供的中间件，对Token进行验证  对请求进行身份验证，并且此时需要重新更改所有用到的函数
- 所以需要在函数中，添加从上下文获取的username、account，只有从前后文获取到的实体，才能对这个账号，username进行更改
- 类型与令牌之间必须是以空格为间隔的



v2.local.fats1IAs_9BvacmkVy9PGsYJ2u6Y7yWwuux9GJp1-UCJFPasrzuyNs0r60l0pm20-7fqdnAEUAHI7c6okhV6io2gGwjpl094JEJFx4FU7_l4vJn4Mxj-yP660mg8GymHw-THEpItxz5LhWvAhyEHQRFhp4aPYkRvijilfcBY8p3wfeTFfSkKCO_cB4dV1GDDoIhmLikVplnyqynOKdAnWkPKB46oYdZ-XPb8AVEmhqFZAcYnDHk8df364uv1QvuBj7E1VNhais4LkA.bnVsbA

dylanz
v2.local.pQrKoW93kaTbXaKr8URCa19J7EIqQd4m0H4SHDfa1FE-2YYerURhmMjBzz0fiYdMusSkp86eewzOH8Gi2lcSfWli9nN-WlowEyUMFnR0ejCS2sojZqnHblpo4TfVcybBU8kKW9qbIm1NlR-dsBcRF_3_Gucpl8PxQAlXlyst-_d9nyfYMq1TYYT70VdTKQO7-Q7TvkvTOUfnif_X59GkKbKVofzlrDI-61uwEqgNjMQhm08ztnU3F2pq0tVqPDpBhkV1wofV2dTrMg.bnVsbA




###### 构建docker镜像，就是将本地的所有项目打包，并且直接构造镜像
```bash


```
###### 分阶段构造镜像- 将镜像分级
- 首先，构建二进制文件
```docker
	AS build是可以的
```
- 其次就是运行阶段

RUN 就是将构建过来的二进制文件，进行运行


###### 创建docker容器，
- -e 容器需要的参数
- -p 暴露的端口映射


###### 创建一个用户自己的docker Network 让两个容器之间可以在同一个网络下运行，进而能够直接通过网络节点的名字来访问彼此
- 两个容器之间是没有网络连接的，因为两个容器的IP地址并不一样，所以在使用localhost的时候，会有问题

```bash
	#查看此时有哪些网络
	docker network ls
	#查看具体网络中，有哪些容器正在连接
	docker network inspect network-name
	#创建一个新的网络桥段
	docker network create network-name
	#把容器添加到这个网络桥段之中
	docker network connect network-name container-name
```
- 这样就可以很好的解决网络问题 


###### 通过一个docker compose来创建多个想要的容器，并且编写一个yaml文件，来对这个项目进行配置即可


###### 刷新令牌的机制、避免繁琐的重复性登录，所以就是设置一个持续时间长的，用于获取短的
- access_token 、 refresh_token


###### 学会使用工具  有一个文档生成器，可以用来可视化数据库表
###### dbdocs
```bash
	npm install -g dbdocs
```
- 之后就是查文档了

```http
	https://dbdiagram.io/
```


