## 银行管理项目

##### 利用window的Makefile，需要自行安装某些包，才能使用make指令，来简便的快速创建一个项目

```bash
GNU Make 
```

利用docker的容器镜像性，来对使用sqlc，来自动生成代码用的

```bash
docker run --rm -v "$具体项目路径:/src" -w /src sqlc/sqlc generate
```



##### 数据库的事务性，能够自动进行一次事务的提交，回滚

数据库的表格，E-R图可以使用工具

```http
https://dbdiagram.io/d
```

还可以使用迁移，来对数据库的数据表的结构，迁移到对应的版本的结构

migrate 使用指令

//用于具体的数据库表的迁移结构
```go
migrate -path db/migration -database "postgresql://postgres:cst4Ever@localhost:5432/mypostgres?sslmode=disable" -verbose down

//用于创建新的数据库迁移脚本
```bash
migrate create -ext sql -dir db/migration -seq add_sessions
```





##### 使用postman来对自己的接口进行测试，直接调用的方式





##### 使用gin框架，来快速搭建一个路由处理。这个接收数据结构体是利用gin的上下文，再解析出来的

```go
	router := gin.Default()

	router.POST("/accounts", server.CreateAccount)
	router.GET("/dsad"，任何中间件加函数)
```

从上下文中解析这个传进来的结构体

```go
func (server *Server) CreateUser(ctx *gin.Context) {
	var req createUserRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}
    ...
    
}
```





使用后Golang自定的mock，来模拟对http跟数据库的操作

使用包：

```bash
go install github.com/golang/mock/mockgen@v1.6.0
```

- 模拟数据库：需要使用一个新的接口替换掉真实链接数据库的接口
- 此处需要了解真实的接口是怎么做的
- 需要在sqlc的配置文件中，定义好一个全部接口的类型

```yaml
    emit_interface : true
```

```go
type Store interface {
	Querier
	//实现接口的定义,只要一个接口，实现了一个结构体的方式，就可以弄一个返回为同一个类型
	TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) 
}


type SQLStore struct {
	*Queries
	db *sql.DB
}
```

执行指令

```bash
mockgen -package mockdb  -destination db/mock/store.go  Project/db/sqlc Store
```

来在对应为目录生成mock代码函数

##### 在使用mock代码的时候，需要每种不同类型的请求，需要包含的参数不一样
```go
	testCases := []struct {
		name          string
		body          gin.H
		buildStubs    func(store *mockdb.MockStore)
		checkResponse func(recoder *httptest.ResponseRecorder)
		setupAuth func(t *testing.T, request *http.Request, tokenMaker token.Maker)
	}
```
- name 就是表示这个用例是测试什么情况的
- body 就是在测试这个请求的时候，给gomock发送的数据结构体
- buildStubs 用于定义这个请求预期的效果，用于参数检测的(并不完全检测参数，而是检验在mock生成代码的结构体的数据)
- checkResponse 是用于检测最终返回的值，状态码的检测
- setupAuth 用于检验令牌合理性
...

去验证每一个函数的，满足百分百的代码覆盖度

##### 在模拟发送http请求的时候，如果是需要Get的方式，需要在请求的URL上添加上需要的参数名
```go
			// Add query parameters to request URL
			q := request.URL.Query()
			q.Add("page_id", fmt.Sprintf("%d", tc.query.pageID))
			q.Add("page_size", fmt.Sprintf("%d", tc.query.pageSize))
			request.URL.RawQuery = q.Encode()

```
添加上对应的查询parameters ，最终使用 server.router.ServeHTTP(recorder, request)发送最终的请求


##### 还可以使用gin框架自带的验证传输的JSON码的格式是否符合预期

```go
var validCurrency validator.Func = func(fieldLevel validator.FieldLevel) bool {
   if curency , ok := fieldLevel.Field().Interface().(string); ok{
        return utils.IsSupportedCurrency(curency)
   }
   return false
}
```



利用这个validator助手，注册一个是否成功的函数。随后需要在gin框架初始化的时候进行注册

```go
	if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
		v.RegisterValidation("currency", validCurrency)
	}
```

```go
package api

import (
	"Project/utils"

	"github.com/go-playground/validator/v10"
)

var validCurrency validator.Func = func(fieldLevel validator.FieldLevel) bool {
   if curency , ok := fieldLevel.Field().Interface().(string); ok{
        return utils.IsSupportedCurrency(curency)
   }
   return false
}
//之后可以进行直接对JSON使用这个`json:"currency" binding:"required,currency"`
```

需要注册一个函数，返回是否通过的一个闸口


##### 设置并验证Token的方式
- 有两种方法：(重点都是围绕着这个maker来获取)
	- **JWT**
	需要创建负载，通过负载，并且添加加密方式，来创建一个
	```go
	func (maker *JWTMaker) CreateToken(username string, duration time.Duration) (string, error) {
	//创建一个新的Token负载
	payload, err := NewPayload(username, duration)
	if err != nil {
		fmt.Println(err)
		return "", err
	}
	//创建一个token令牌
	jwtTocker := jwt.NewWithClaims(jwt.SigningMethodHS256, payload)
	return jwtTocker.SignedString([]byte(maker.secretKey))
	}
	```
	随后对Token进行验证
	```go
	func (maker *JWTMaker) VerifyToken(token string) (*Payload, error) {
	//定义的一个匿名函数：作为提供验证JWT令牌需要的秘钥
	keyFunc := func(token *jwt.Token) (interface{}, error) {
		_, ok := token.Method.(*jwt.SigningMethodHMAC)
		if !ok {
			return nil, ErrInvalidToken
		}
		return []byte(maker.secretKey), nil
	}
	jwtToken, err := jwt.ParseWithClaims(token, &Payload{}, keyFunc)
	if err != nil {
		verr, ok := err.(*jwt.ValidationError)
		if ok && errors.Is(verr.Inner, ErrExpiredToken) {
			return nil, ErrExpiredToken
		}
		return nil, ErrInvalidToken
	}
	payload, ok := jwtToken.Claims.(*Payload)
	if !ok {
		return nil, ErrInvalidToken
	}
	return payload, nil
	}
	```
	- **Paseto**
	这个就简单很多，只需要调用某一个函数，给他添加上即可
	```go
	//创建
	pateoMaker.paseto.Encrypt(pateoMaker.symmertricKey, payload, nil)
	//验证
	pateoMaker.paseto.Decrypt(token, pateoMaker.symmertricKey, payload, nil)
	```
	```go
	func (pateoMaker *PateoMaker) CreateToken(username string, duration time.Duration) (string, error) {
	payload, err := NewPayload(username, duration)
	if err != nil {
		return "", err
	}
	return pateoMaker.paseto.Encrypt(pateoMaker.symmertricKey, payload, nil)
	}
	```



##### 哈希对用户的密码进行加密存储在数据库中
- 通过有一个固定次序，来对每一次密码进行加密,即使相同的密码，他们的哈希密码也还是不同的



##### 检验每一次申请连接的令牌是否超出预期
- 有敏感数据的话，需要重新定义一个response的数据结构
```go
type userResponse struct {
	Username          string    `json:"username"`
	FullName          string    `json:"full_name"`
	Email             string    `json:"email"`
	PasswordChangedAt time.Time `json:"password_changed_at"`
	CreatedAt         time.Time `json:"created_at"`
}

func newUserResponse(user db.User) userResponse {
	return userResponse{
		Username:          user.Username,
		FullName:          user.FullName,
		Email:             user.Email,
		PasswordChangedAt: user.PasswordChangedAt,
		CreatedAt:         user.CreatedAt,
	}
}

	rep := newUserResponse(user)
	ctx.JSON(http.StatusOK, rep)
```


##### 令牌的作用：某些查询或者操作的指令，必须拥有访问的token，才能有权限修改或者查询，否则无法进行
- 也就是说：很多API的请求结构体要发生变化，不需要再提供关于自己的用户名，而是通过保存在请求里面的Token进行获取
- 这样就避免用户端那边在发送请求的时候进行作弊
- 也就是说，需要从上下文的存储的自定义的负载中，获取想要的信息
	```go
	type Payload struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	IssuedAt  time.Time `json:"issued_at"`
	ExpiredAt time.Time `json:"expired_at"`
	}
	```




##### 使用gin提供的中间件，对Token进行验证  对请求进行身份验证，并且此时需要重新更改所有用到的函数
- 所以需要在函数中，添加从上下文获取的username、account，只有从前后文获取到的实体，才能对这个账号，username进行更改
- 类型与令牌之间必须是以空格为间隔的

##### 刷新令牌的机制、避免繁琐的重复性登录，所以就是设置一个持续时间长的，用于获取短的
- access_token 、 refresh_token


v2.local.fats1IAs_9BvacmkVy9PGsYJ2u6Y7yWwuux9GJp1-UCJFPasrzuyNs0r60l0pm20-7fqdnAEUAHI7c6okhV6io2gGwjpl094JEJFx4FU7_l4vJn4Mxj-yP660mg8GymHw-THEpItxz5LhWvAhyEHQRFhp4aPYkRvijilfcBY8p3wfeTFfSkKCO_cB4dV1GDDoIhmLikVplnyqynOKdAnWkPKB46oYdZ-XPb8AVEmhqFZAcYnDHk8df364uv1QvuBj7E1VNhais4LkA.bnVsbA

dylanz
v2.local.pQrKoW93kaTbXaKr8URCa19J7EIqQd4m0H4SHDfa1FE-2YYerURhmMjBzz0fiYdMusSkp86eewzOH8Gi2lcSfWli9nN-WlowEyUMFnR0ejCS2sojZqnHblpo4TfVcybBU8kKW9qbIm1NlR-dsBcRF_3_Gucpl8PxQAlXlyst-_d9nyfYMq1TYYT70VdTKQO7-Q7TvkvTOUfnif_X59GkKbKVofzlrDI-61uwEqgNjMQhm08ztnU3F2pq0tVqPDpBhkV1wofV2dTrMg.bnVsbA






##### 分阶段构造镜像- 将镜像分级
- 首先，构建二进制文件
```docker
	AS build是可以的
```
- 其次就是运行阶段

RUN 就是将构建过来的二进制文件，进行运行

```Dockerfile
# 使用镜像GO语言的镜像，对项目进行打包
FROM golang:1.21.2-alpine3.20 AS builder
# 定好工作目录
WORKDIR /app
# 将哪个路径下的文件进行打包，并且被复制到哪里
COPY . .
# 进入到容器后执行的命名
RUN go build -o main main.go
RUN apk add curl
run curl -L https://github.com/golang-migrate/migrate/releases/download/v4.18.1/migrate.linux-amd64.tar.gz | tar xvz


//是可以从builder里面进行拷贝可执行文件的部署，第二个创建的才是真正构建的image
# RUN stage
FROM alpine:3.20
WORKDIR /app
COPY --from=builder /app/main .
COPY --from=builder /app/migrate ./migrate
COPY app.env . 
COPY start.sh . 
COPY wait-for.sh . 
COPY db/migration ./migration
# 暴露那些端口
EXPOSE 8080
# 执行文件
CMD [ "/app/main" ]
ENTRYPOINT [ "/app/start.sh" ]


```


##### 创建docker容器，
- -e 容器需要的参数：给容器配置环境变量
- -p 暴露的端口映射


##### 创建一个用户自己的docker Network 让两个容器之间可以在同一个网络下运行，进而能够直接通过网络节点的名字来访问彼此
- 两个容器之间是没有网络连接的，因为两个容器的IP地址并不一样，所以在使用localhost的时候，会有问题

```bash
	#查看此时有哪些网络
	docker network ls
	#查看具体网络中，有哪些容器正在连接
	docker network inspect network-name
	#创建一个新的网络桥段
	docker network create network-name
	#把容器添加到这个网络桥段之中
	docker network connect network-name container-name
```
- 这样就可以很好的解决网络问题 





##### 学会使用工具  有一个文档生成器，可以用来可视化数据库表
##### dbdocs
```bash
	npm install -g dbdocs
```
- 之后就是查文档了

```http
	https://dbdiagram.io/
```



##### docker compose 的使用：一起部署一个项目：最主要的是需要编写compose.yaml的文件
```bash
docker compose up

docker compose down

```

会自动在目录中寻找docker-compose.yaml的文件，对项目进行部署


##### 使用yml进行更新的时候，就自动构建新的images，能够进行部署项目，并且真实的连接到数据库中
- 需要在github上找到action的标准镜像，随后在编写：具体详见deploy.yml
```yml
jobs:
  build:
    name: Build image
    runs-on: ubuntu-latest
    steps:
      - name: Check out Code into the Go module diectory
        uses: actions/checkout@v2
      
      -
        name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      -
        name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      -
        name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      -
        name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ailanz/simple_bank:latest
```

##### 使用kubernetes 的集群，是可以轻松的部署多个项目到集群上，便于管理
###### 使用集群的话，实际上只有代码监听的端口是有作用的，其余的IP地址只有个数据库的连接有作用；因为容器会帮你做转发，一个服务是会实例化在一个ecs上面的
- 先到nginx - 再到ingress的转接 - 最后再到具体设置的服务
- 再部署一个集群的容器，用于监听信号，转发对应的信号到集群的服务容器上
- 单位是一个pod，每一个服务就是一个pod，kubernetes会自动进行负载均衡的对请求进行分配
- 也就是说会自动开设一个ECS实例，来保存一个服务
- 里面需要设置集群、节点、pod
- 所有的pod都会定义到同一个域名解析上

![alt text](image.png)




##### GRPC
###### 定义一个新的GRPC服务器 （不同时监听http的请求，需要设置网关）
代码生成，但是需要将结构的API跟GRPC的API进行分离，进而结构的值是需要转化的
使用proto的文件结构来
这里需要一种辅助的插件与文件proto：也就是GO语言的GRPC
```bash
$ go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```
- 首先：需要先写好proto文件，把需要的结构体、方法、服务分别写成proto文件（具体的书写要求可以以后再学）
- 定义的类：包含两个方法
```proto
syntax = "proto3";

package pb;

import "google/api/annotations.proto";
import "rpc_create_user.proto";

import "rpc_login_user.proto";

option go_package = "Project/pb";


service SimpleBank {
    rpc CreateUser (CreateUserRequest) returns (CreateUserResponse) {
      option (google.api.http) = {
        post: "/v1/create_user"
        body: "*"
      };
    }
    rpc LoginUser (LoginUserRequest) returns (LoginUserResponse) {
      option (google.api.http) = {
        post: "/v1/login_user"
        body: "*"
      };
    }
}

```
定义的两个结构体，用于指定方法用的
```proto
syntax = "proto3";

package pb;

import "user.proto";
import "google/protobuf/timestamp.proto";

option go_package = "Project/pb";


message LoginUserRequest {
    string username = 1;
    string password = 2;
}

message LoginUserResponse {
    string session_id = 1;
    string access_token = 2;
    google.protobuf.Timestamp access_token_expires_at = 3;
    string refresh_token = 4;
    google.protobuf.Timestamp refresh_token_expires_at = 5;
    User user = 6;
}
```
之后就能通过语句来生成GRPC适用于GOlang的代码
```bash
$ protoc --go_out=. --go_opt=paths=source_relative \
    --go-grpc_out=. --go-grpc_opt=paths=source_relative \
    helloworld/helloworld.proto
```
就可以在对应的目录上看到生成的代码；随后需要注册一个新的监听服务：之后就能够在evans的图形化界面对这个GRPC生成的服务器进行访问、操作
```go
server, err := gapi.NewServer(config, store)
	if err != nil {
		logger.Sugar().Errorf("failed : %s", err)
	}

	grpcServer := grpc.NewServer()
	pb.RegisterSimpleBankServer(grpcServer, server)
	reflection.Register(grpcServer)

	listener, err := net.Listen("tcp", config.GRPCServerAddress)
	if err != nil {
		logger.Error("can not create Listener----> runGrpcServer")
	}
	logger.Sugar().Info("start GRPC server at %s----> run GRPCServer", listener.Addr().String())
	err = grpcServer.Serve(listener)
	if err != nil {
		logger.Error("can not start Server----> runGrpcServer")
	}
```
###### 利用gateway网关，同步监听http的请求
- 使用包grpc-ecosystem/grpc-gateway
```go
import (
    _ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway"
    _ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2"
    _ "google.golang.org/grpc/cmd/protoc-gen-go-grpc"
    _ "google.golang.org/protobuf/cmd/protoc-gen-go"
)
```
导入这几个包，并且使用指令go install他们，就能对应的生成网关同步监听HTTP请求
在之前的方法结构体上，添加字段 
```proto
	 rpc CreateUser (CreateUserRequest) returns (CreateUserResponse) {
      option (google.api.http) = {
        post: "/v1/create_user"
        body: "*"
      };
    }
```
在生成的proto代码里面，就会有网关的注册函数，在主程序中多开一个协程来监听网关的端口即可
![alt text](image-1.png)


###### 在使用grpc的工具时候，如何获取客户的IP地址与用户代理
- 元数据
在**网关**的请求中，上下文携带中获取来自GRPC截获的元数据
使用以下语句即可
```go
//获取来的是一个元数据Map,需要通过字段来进行获取，结构如下：
const (
	grpcGatewayUserAgentHeader = "grpcgateway-user-agent"
	xForwadredForHeader        = "x-forwarded-for"
	userAgentHeader            = "user-agent"
)

 md , ok := metadata.FromIncomingContext(ctx)
 
 ```

 但是在普通的GRPC服务端中，则不会获取**IP地址**
 所以需要使用peer包
 ```go
 p, ok := peer.FromContext(ctx)
 ```
###### 可以生成一个JSON数据表，对于GRPC的结构与服务
在proto指令上添加 -- protoc-gen-openapiv2的指令 查看 --help查看指令
- 随后使用工具，能够在本地的GOlang服务器部署一个文件查看的网址，并且开放端口让本地进行访问 swagger ui 的工具


###### 部署docker时，不想把刚刚所有的前端的静态文件都copy都到镜像里面怎么办
使用 statik 将静态资源编译进二进制文件中，也就是符合GO语言运行的一个机制：一个二进制的可执行文件
安装包：
```bash
_ "github.com/rakyll/statik"
#使用命令
go install "github.com/rakyll/statik"
```
- 随后就能使用指令 statik -src=./doc/swagger -dest=./doc
来对对应的静态文件直接编译生成二进制数据，直接跟GO的后端文件绑定了
这个工具，是直接把数据与元素都放到服务的内存上了，并不是从这个容器的硬盘上进行读取的，所以速度会加快很多


##### 要让返回给前端信息时，通知是什么类型的错误，必须有一个错误返回的规范：一个让用户看起来整洁，易懂，一眼就清楚是哪里出了问题
- 在进入GRPC的服务函数之前，需要先经过一个自己编写的数据验证器
	- 通过正则校验规则，还有使用grpcerrdetails的结构
- 之后马上就可以返回一组错误信息（由GRPC信息结构组成的一个）
要知道的是：
grpc的错误信息是一个结构体来的，因此需要定义两个信息
```go 
type BadRequest_FieldViolation struct {
    Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
    // A description of why the request element is bad.
    Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
}
```

之后用到statusDetails，将这些错误信息，组合在一起
```go
	statusInvalid := status.New(codes.InvalidArgument, "invalid parameters")
	statusDetails, err := statusInvalid.WithDetails(badRequest)

```
最后返回的错误是这个结构体即可









